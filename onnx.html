<!DOCTYPE html>
<html>

<head> 
    <meta charset="utf-8"> 
    <title>Image Classification</title> 
    <link href="js_example_style.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
        .inputoutput{
            float: left
            margin: 10px
        }
    </style>
</head>

<body>

    <h2>Image Classification</h2>
    <p id="status"Opencv.js is loading...></p>

    <div>
        <div class="inputoutput">
            <img id="imgsrc" width="224" height="224" alt="No image" />
            <div class="caption">test image <input type="file" id="fileinput" name="file" /> </div>
        </div>
        <div class="inputoutput">
            <canvas id="canvasoutput"></canvas>
            <div calss="caption">canvasoutput</div>
        </div>
    </div>
    <script src="opencv.js"  type="text/javascript"></script>

    <script type="text/javascript">
    cv.onRuntimeInitialized = () => {
        console.log("opencv.js loaded");
        let imgelement = document.getElementById("imgsrc");
        let inputelement = document.getElementById("fileinput");
        inputelement.addEventListener("change", (e) =>{
            imgelement.src = URL.createObjectURL(e.target.files[0]);
        }, false)

        let net;
        let keywords;

        function opencvready(){
            document.getElementById("status").innerHTML = "opencv.js is ready."
        }

        imgelement.onload = async function(){
                let mat = cv.imread("imgsrc");
                cv.imshow("canvasoutput", mat);
                let matC3 = new cv.Mat(mat.matSize[0],mat.matSize[1],cv.CV_8UC3);
                cv.cvtColor(mat, matC3, cv.COLOR_RGBA2RGB);

                let matdata = matC3.data
                let stddata = []

                for(var i=0; i<mat.matSize[0]*mat.matSize[1]; ++i){
                    stddata.push( (matdata[3*i]/255-0.485)/0.229 ); 
                    stddata.push( (matdata[3*i+1]/255-0.456)/0.224 ); 
                    stddata.push( (matdata[3*i+2]/255-0.406)/0.225 );
                }

                // let normdata = []
                // for(var k=0; k<mat.matSize[0]*mat.matSize[1]; ++k){
                //     for(var j=0; j<3; ++j){
                //         normdata.push(stddata[j*mat.matSize[0]*mat.matSize[1]+k])
                //     }
                // }

                let newMat = cv.matFromArray(mat.matSize[0],mat.matSize[1],cv.CV_32FC3,stddata)

                // cv.cvtColor(newMat, newMat, cv.COLOR_BGR2RGB)

                console.log('load model...')
                let onnxmodel = 'squeezenet1.1.onnx';
                    createFileFromUrl(onnxmodel, onnxmodel, () =>{
                        let url = 'labels1000.txt';
                        let request = new XMLHttpRequest();
                        request.open('GET', url, true);
                        request.onload = function(ev) {
                            if (request.readyState ===4 ) {
                                if(request.status === 200) {
                                    keywords = request.response;
                                    keywords = keywords.split('\n')
                                    setTimeout(() => {
                                        net = cv.readNetFromONNX(onnxmodel);
                                        // if (net.empty()) {
                                        //     throw Error('failed to read net')
                                        // }
                                        console.log('start inference...')
                                        let input = cv.blobFromImage(newMat, 1, new cv.Size(224, 224), new cv.Scalar(0,0,0));
                                        net.setInput(input);

                                        let start = Date.now();
                                        var result = net.forward();
                                        let end = Date.now()

                                        let classes = getTopClasses(result, keywords, 5)
                                        console.log(classes)
                                        let delta = end - start
                                        console.log('inference time: ' + delta + 'ms' )
                                    })
                                }
                            }
                        };
                        request.send();
                    });
        };

    
}

    function createFileFromUrl(path, url, callback){
        let request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';
        request.onload = function(ev) {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    let data = new Uint8Array(request.response);
                    cv.FS_createDataFile('/', path, data, true, false, false);
                    callback();
                } else {
                    console.log('Failed to load ' + url + ' status: ' + request.status);
                }
            }
        };
        request.send();
    };

    function softmax(arr) {
        const C = Math.max(...arr);
        const d = arr.map((y) => Math.exp(y - C)).reduce((a, b) => a + b);
        return arr.map((value, index) => { 
            return Math.exp(value - C) / d;
        })
    }


    function getTopClasses(mat, labels, k = 5) {
        let initdata = mat.data32F;
        initdata = softmax(initdata);
        let probs = Array.from(initdata);
        let indexes = probs.map((prob, index) => [prob, index]);
        let sorted = indexes.sort((a, b) => {
        if (a[0] === b[0]) {return 0;}
        return a[0] < b[0] ? -1 : 1;
        });
        sorted.reverse();
        let classes = [];
        for (let i = 0; i < k; ++i) {
        let prob = sorted[i][0];
        let index = sorted[i][1];
        let c = {
            label: labels[index],
            prob: (prob * 100).toFixed(2)
        }
        classes.push(c);
        }
        return classes;
    }
    </script>

</body>

</html>
